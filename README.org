[[./hercules.png]]

An auto-magical, =which-key= based =hydra= banisher.

* Overview
** Standalone
With almost no set-up code, =hercules.el= lets you call any group of
related command sequentially with no prefix keys, while showing a
handy popup to remember the bindings for those commands. =hercules.el=
can create both of these (the grouped commands, and the popup) from
any keymap. Here's what that looks like:

#+BEGIN_SRC emacs-lisp
  ;; `define-key' and `bind-key' also work
  (my:elisp::general-def
    "m." (hercules-def
          :toggle-funs #'macrostep-mode
          :keymap 'macrostep-keymap
          :transient-mode-fun #'macrostep-mode))
#+END_SRC

[[./hercules.gif]]

** Relative to Other Packages
If only there was a way to make a =hydra= without having to list all
the bindings explicitly... Kind of like =which-key=...

=hercules.el= implements the functionality of
[[https://github.com/abo-abo/hydra][hydra]] by leveraging
[[https://github.com/justbur/emacs-which-key][which-key]] auto-magic.

Unlike =hydra=, =hercules.el= entry and exit points are associated
with functions, not keys (though it can be bound to keys). Keys, on
the other hand, are defined by traditional keymaps, which you can use
as-is, or tweak to your liking using your tool of
choice. =hercules.el= doesn't force this choice on you. That said, I
highly recommend [[https://github.com/noctuid/general.el][general.el]]
if you're out for completely custom pop-ups. You can just create a
keymap from scratch and pass it to =hercules.el=, which =general= does
extremely quickly without compromising flexibility.

Ultimately, =hercules.el= saves you time by relying on work that has
already been done for you --- usually, but not necessarily, as part of
a time-tested minor-mode. The resulting interfaces tend to be more
comprehensive than home-grown =hydras=, thus aiding you in
discovering new functionality.

Allow me to illustrate my point using an example from =hydras= README:

*** Hydra Setup
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-buffer-menu (:color pink
                               :hint nil)
    "
  ^Mark^             ^Unmark^           ^Actions^          ^Search
  ^^^^^^^^-----------------------------------------------------------------
  _m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch
  _s_: save          _U_: unmark up     _b_: bury          _I_: isearch
  _d_: delete        ^ ^                _g_: refresh       _O_: multi-occur
  _D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only
  _~_: modified
  "
    ("m" Buffer-menu-mark)
    ("u" Buffer-menu-unmark)
    ("U" Buffer-menu-backup-unmark)
    ("d" Buffer-menu-delete)
    ("D" Buffer-menu-delete-backwards)
    ("s" Buffer-menu-save)
    ("~" Buffer-menu-not-modified)
    ("x" Buffer-menu-execute)
    ("b" Buffer-menu-bury)
    ("g" revert-buffer)
    ("T" Buffer-menu-toggle-files-only)
    ("O" Buffer-menu-multi-occur :color blue)
    ("I" Buffer-menu-isearch-buffers :color blue)
    ("R" Buffer-menu-isearch-buffers-regexp :color blue)
    ("c" nil "cancel")
    ("v" Buffer-menu-select "select" :color blue)
    ("o" Buffer-menu-other-window "other-window" :color blue)
    ("q" quit-window "quit" :color blue))

  (define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body)
#+END_SRC

*** hercules.el Setup
NOTE: This is the equivalent of hydra's buffer setup applied to window
manipulation, since I don't use buffer-menu. Implementing it yourself
should be trivial.
#+BEGIN_SRC emacs-lisp
  ;; using general.el here instead of `define-key'
  (my:core::general-def
    "w." (hercules-def
          :hide-funs '(windresize-exit windresize-cancel-and-quit)
          :keymap 'windresize-map
          :transient-mode-fun #'windresize))
#+END_SRC

** Bonus
Last, and definitely least, =hercules.el= provides a more consistent
interface for all your keybinding popup needs (the same =which-key= UI
throughout your config).

* Motivation 
As mentioned, I initially wrote =hercules.el= to avoid reinventing the
wheel by creating elaborate hydras for minor-modes that already worked
like they had them, merely lacking the handy popup. These include:

- =macrostep-mode=
- =edebug-mode=
- =debugger-mode=
- =windresize=
- many more
  
But =hercules= can use any keymap you have lying around. It can also
associate it with an arbitrary function on entry. You might recognize
this description --- It creates a pseudo-mode (dubbed =transient-mode=
for its transient keymap) with a cheat-sheet thrown in for good
measure. For example, you can steal =org-babel-map= and whip up what
used to be a massive =hydra= in seconds. Just bind the return value of
this macro to the key you would usually bind the =*-hydra/body= to:

#+BEGIN_SRC emacs-lisp
  ;; again, `define-key' and `bind-key' also work
  (my:org::general-def
    "b." (hercules-def
          :keymap 'org-babel-map
          :transient-mode t))
#+END_SRC

Pressing any key outside the map will leave the =transient-mode=. But
you can also use the =(hide|toggle)-funs= arguments to leave the
=transient-mode= while executing one last Hail Mary command.

* Interface
The only userland macro you should concern yourself with is
=hercules-def=. As such, you should get to know it well.

** Arguments
The following arguments define entry and exit point functions that
invoke =hercules.el= (both lists and single functions work):
 
- TOGGLE-FUNS :: Processed with =hercules--toggle-funs=.
- SHOW-FUNS :: Processed with =hercules--show-funs=.
- HIDE-FUNS :: Processed with =hercules--hide-funs=.

The following arguments provide a shorthand for
whittling down =hercules.el= pop-ups if you don't want to get your
hands dirty with keymaps and prefer a more minimal UI (both lists
and single keys/functions work, and blacklists take precedence
over whitelists):

- BLACKLIST-KEYS :: Processed with =hercules--graylist-after-load=.
- WHITELIST-KEYS :: Processed with =hercules--graylist-after-load=.
- BLACKLIST-FUNS :: Processed with =hercules--graylist-after-load=.
- WHITELIST-FUNS :: Processed with =hercules--graylist-after-load=.

Now to the slightly less obvious options:

- KEYMAP :: The keymap for =hercules.el=. If it is nil, it is assumed
  that the function you are calling will result in a
  =which-key--show-popup= call. This might be desirable if you wish to
  enable =hercules.el= for =which-key-show-top-level= or something
  similar. For example, this is what I have in my config so I can
  scroll to the =which-key= page of interest when I'm dealing with
  some fringe Evil commands I kind of forgot. Then I keep it around
  until I feel comfortable enough to kill it with
  =keyboard-quit=. This has the side effect of killing any
  =hercules.el= pop-up on =keyboard-quit=, but then again all commands
  are supposed to obey it.
  
 #+BEGIN_SRC emacs-lisp
   ;; no need to bind to any key
   (hercules-def
    :show-funs #'which-key-show-top-level
    :hide-funs '(keyboard-quit keyboard-escape-quit))
 #+END_SRC 
 
- PACKAGE :: If you are using any of BLACKLIST-KEYS, WHITELIST-KEYS,
  BLACKLIST-FUNS, or WHITELIST-FUNS, and the KEYMAP you're dealing is
  in a lazy-loaded package, you must also specify the package it
  belongs to as a quotes symbol using this argument.

- CONFIG :: A dummy argument the pedantic among us can use to execute
  =hercules.el= related configuration code in the same place as
  =hercules-def=.  The most common use case will most likely be to
  tweak keymaps with more precision than the
  =(BLACK|WHITE)LIST-(KEYS|FUNS)= arguments allow, or to define new
  keymaps from scratch for complete control. At that point you'd
  basically be building a hydra, but you'd still be saving effort in
  my opinion. You could leverage the power of whichever keybinding
  engine you prefer, and bind nested keymaps to keys without worrying
  about =*-hydra/body= abstractions or manually specifying anything
  beyond what you ECD (Emacs Compulsive Disorder) compels you
  to. =hercules.el= will simply follow you where needed. Here's a
  pseudo-example:

#+BEGIN_SRC emacs-lisp
   (hercules-def
    :show-funs #'my-show-fun
    :hide-funs #'my-hide-fun
    :keymap 'my-map
    :config (general-def
              :prefix-map 'my-map
              "h" #'my-hide-fun
              "s" #'my-show-fun
              "m" 'my-keymap-1
              "n" 'my-keymap-2
              ;; +++
              ))
#+END_SRC
